package disgo

// Warning: This file has been automatically generated by generate/state/main.go
// Do NOT make changes here, instead adapt generate/generate.go and run go generate

import "sync"

type state struct {
	users       map[Snowflake]*User
	userLock    sync.RWMutex
	guilds      map[Snowflake]*Guild
	guildLock   sync.RWMutex
	channels    map[Snowflake]*Channel
	channelLock sync.RWMutex
	messages    map[Snowflake]*Message
	messageLock sync.RWMutex
	roles       map[Snowflake]*Role
	roleLock    sync.RWMutex
}

var objects = &state{
	users:    make(map[Snowflake]*User),
	guilds:   make(map[Snowflake]*Guild),
	channels: make(map[Snowflake]*Channel),
	messages: make(map[Snowflake]*Message),
	roles:    make(map[Snowflake]*Role),
}

func (s *state) registerUser(id identifiableObject) *User {
	s.userLock.RLock()
	registered, exists := s.users[id.ID()]
	s.userLock.RUnlock()
	if exists {
		return registered
	}

	user, typeOk := id.(*User)
	if !typeOk {
		user = &User{internal: &internalUser{}, lock: new(sync.RWMutex)}
	}
	s.userLock.Lock()
	s.users[id.ID()] = user
	s.userLock.Unlock()
	return user
}

func (s *state) registerGuild(id identifiableObject) *Guild {
	s.guildLock.RLock()
	registered, exists := s.guilds[id.ID()]
	s.guildLock.RUnlock()
	if exists {
		return registered
	}

	guild, typeOk := id.(*Guild)
	if !typeOk {
		guild = &Guild{internal: &internalGuild{}, lock: new(sync.RWMutex)}
	}
	s.guildLock.Lock()
	s.guilds[id.ID()] = guild
	s.guildLock.Unlock()
	return guild
}

func (s *state) registerChannel(id identifiableObject) *Channel {
	s.channelLock.RLock()
	registered, exists := s.channels[id.ID()]
	s.channelLock.RUnlock()
	if exists {
		return registered
	}

	channel, typeOk := id.(*Channel)
	if !typeOk {
		channel = &Channel{internal: &internalChannel{}, lock: new(sync.RWMutex)}
	}
	s.channelLock.Lock()
	s.channels[id.ID()] = channel
	s.channelLock.Unlock()
	return channel
}

func (s *state) registerMessage(id identifiableObject) *Message {
	s.messageLock.RLock()
	registered, exists := s.messages[id.ID()]
	s.messageLock.RUnlock()
	if exists {
		return registered
	}

	message, typeOk := id.(*Message)
	if !typeOk {
		message = &Message{internal: &internalMessage{}, lock: new(sync.RWMutex)}
	}
	s.messageLock.Lock()
	s.messages[id.ID()] = message
	s.messageLock.Unlock()
	return message
}

func (s *state) registerRole(id identifiableObject) *Role {
	s.roleLock.RLock()
	registered, exists := s.roles[id.ID()]
	s.roleLock.RUnlock()
	if exists {
		return registered
	}

	role, typeOk := id.(*Role)
	if !typeOk {
		role = &Role{internal: &internalRole{}, lock: new(sync.RWMutex)}
	}
	s.roleLock.Lock()
	s.roles[id.ID()] = role
	s.roleLock.Unlock()
	return role
}
