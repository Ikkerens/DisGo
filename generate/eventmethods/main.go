package main

// +build ignore

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"sort"
	"text/template"
	"unicode"

	"github.com/ikkerens/disgo/generate"
	"github.com/slf4go/logger"
)

type eventDeclaration struct {
	Name      string
	EventName string
	Embed     string

	StarTypes  []registeredEventField
	ArrayTypes []registeredEventField
}

type registeredEventField struct {
	FieldName string
	TypeName  string
}

func main() {
	file, err := parser.ParseFile(token.NewFileSet(), "events.go", nil, 0)
	if err != nil {
		logger.ErrorE(err)
		return
	}

	events := make([]eventDeclaration, 0)
	for name, object := range file.Scope.Objects {
		if object.Kind == ast.Typ {
			event := eventDeclaration{Name: name, EventName: transformName(name), StarTypes: make([]registeredEventField, 0), ArrayTypes: make([]registeredEventField, 0)}
			logger.Infof("Adding EventName() method for %s that returns %s", event.Name, event.EventName)
			fields := object.Decl.(*ast.TypeSpec).Type.(*ast.StructType).Fields.List
			if len(fields) == 1 && len(fields[0].Names) == 0 {
				event.Embed = fields[0].Type.(*ast.StarExpr).X.(*ast.Ident).Name
				if generate.IsRegisteredType(event.Embed) {
					event.StarTypes = append(event.StarTypes, registeredEventField{event.Embed, event.Embed})
				}
				logger.Infof("%s embeds %s, adding Marshal methods", event.Name, event.Embed)
			} else {
				for _, field := range fields {
					switch f := field.Type.(type) {
					case *ast.StarExpr:
						typ := f.X.(*ast.Ident).Name
						if generate.IsRegisteredType(typ) {
							event.StarTypes = append(event.StarTypes, registeredEventField{field.Names[0].Name, typ})
						}
					case *ast.ArrayType:
						star, isStar := f.Elt.(*ast.StarExpr)
						if isStar {
							typ := star.X.(*ast.Ident).Name
							if generate.IsRegisteredType(typ) {
								event.ArrayTypes = append(event.ArrayTypes, registeredEventField{field.Names[0].Name, typ})
							}
						}
					}
				}
			}
			events = append(events, event)
		}
	}

	sort.SliceStable(events, func(i, j int) bool {
		return events[i].Name < events[j].Name
	})

	logger.Infof("Generating GO file")
	var tpl = template.Must(template.New("eventmethods").Parse(`package disgo

		// Warning: This file has been automatically generated by generate/eventmethods/main.go
		// Do NOT make changes here, instead adapt events.go and run go generate

		import (
			"encoding/json"
			"github.com/slf4go/logger"
		)

		func allocateEvent(eventName string) *Event {
			var event Event

			switch eventName { {{range .}}
			case "{{.EventName}}":
				event = &{{.Name}}{} {{end}}
			default:
				logger.Errorf("Event with name '%s' was dispatched by Discord, but we don't know this event. (DisGo outdated?)", eventName)
				return nil
			}

			return &event
		}

		{{range .}}
			func (*{{.Name}}) eventName() string {
				return "{{.EventName}}"
			}

			func (e *{{.Name}}) setSession(s *Session) { {{range .StarTypes}}
					e.{{.FieldName}}.session = s {{end}}
				{{range .ArrayTypes}} for _, item := range e.{{.FieldName}} {
						item.session = s
					}
				{{end}} }

			{{if .Embed}}
				// MarshalJSON is used to make sure the embedded object of this event is Marshalled, not the event itself
				func (e *{{.Name}}) MarshalJSON() ([]byte, error) {
					return json.Marshal(e.{{.Embed}})
				}

				// UnmarshalJSON is used to make sure the embedded object of this event is Unmarshalled, not the event itself
				func (e *{{.Name}}) UnmarshalJSON(b []byte) error {
					e.{{.Embed}} = &{{.Embed}}{}
					return json.Unmarshal(b, &e.{{.Embed}})
				}
			{{end}}
		{{end}}
	`))

	var result []byte
	var buf bytes.Buffer
	err = tpl.Execute(&buf, events)

	if err == nil {
		var formatted []byte
		logger.Infof("Formatting GO file")
		formatted, err = format.Source(buf.Bytes())
		result = formatted
	}

	if err != nil {
		logger.ErrorE(err)
		os.Exit(1)
	}

	ioutil.WriteFile("events_generated.go", result, 0644)
}

func transformName(name string) string {
	var runes = make([]rune, 0)
	for i, c := range name[:len(name)-5] {
		if i != 0 {
			if unicode.IsUpper(c) {
				runes = append(runes, '_')
			}
		}

		runes = append(runes, unicode.ToUpper(c))
	}

	return string(runes)
}
